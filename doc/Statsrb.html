<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>
  Class: Statsrb
  
    &mdash; Documentation by YARD 0.8.6.1
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  hasFrames = window.top.frames.main ? true : false;
  relpath = '';
  framesUrl = "frames.html#!" + escape(window.location.href);
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div id="header">
      <div id="menu">
  
    <a href="_index.html">Index (S)</a> &raquo;
    
    
    <span class="title">Statsrb</span>
  

  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">
      Class List
    </a>
  
    <a class="full_list_link" id="method_list_link"
        href="method_list.html">
      Method List
    </a>
  
    <a class="full_list_link" id="file_list_link"
        href="file_list.html">
      File List
    </a>
  
</div>
      <div class="clear"></div>
    </div>

    <iframe id="search_frame"></iframe>

    <div id="content"><h1>Class: Statsrb
  
  
  
</h1>

<dl class="box">
  
    <dt class="r1">Inherits:</dt>
    <dd class="r1">
      <span class="inheritName">Object</span>
      
        <ul class="fullTree">
          <li>Object</li>
          
            <li class="next">Statsrb</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
      </dd>
    
  
  
    
  
    
  
  
  
    <dt class="r2 last">Defined in:</dt>
    <dd class="r2 last">lib/statsrb.rb<span class="defines">,<br />
  ext/statsrb/statsrb.c</span>
</dd>
  
</dl>
<div class="clear"></div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Author:</p>
<ul class="author">
  
    <li>
      
      
      
      
        
        <div class='inline'>
<p>Kevin Hankens</p>
</div>
      
    </li>
  
</ul>

</div>



  <h2>Instance Attribute Summary <small>(<a href="#" class="summary_toggle">collapse</a>)</small></h2>
  <ul class="summary">
    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#data-instance_method" title="#data (instance method)">- (Object) <strong>data</strong> </a>
    

    
  </span>
  
  
  
    
    
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>An array of hashes keyed with :ts(timestamp), :ns(namespace) and :v(value)
e.g.</p>
</div></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#flush_count-instance_method" title="#flush_count (instance method)">- (Object) <strong>flush_count</strong> </a>
    

    
  </span>
  
  
  
    
    
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>When used with a rack server, the max count of @data before flushing and
writing to file.</p>
</div></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#split_file_dir-instance_method" title="#split_file_dir (instance method)">- (Object) <strong>split_file_dir</strong> </a>
    

    
  </span>
  
  
  
    
    
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>The file directory to write when splitting namespaces.</p>
</div></span>
  
</li>

    
  </ul>




  
    <h2>
      Instance Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#call-instance_method" title="#call (instance method)">- (Object) <strong>call</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Returns a rack-compatible response.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#get-instance_method" title="#get (instance method)">- (Array) <strong>get</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Retrieves internal data based on specified filters.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#initialize-instance_method" title="#initialize (instance method)">- (Object) <strong>initialize</strong> </a>
    

    
  </span>
  
  
    <span class="note title constructor">constructor</span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Class constructor, sets up an instance variable.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#push-instance_method" title="#push (instance method)">- (Statsrb) <strong>push</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Pushes a stat onto the statsrb object.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#query-instance_method" title="#query (instance method)">- (Statsrb) <strong>query</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Locates data from a specified file and loads into @data.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#read-instance_method" title="#read (instance method)">- (Statsrb) <strong>read</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Locates data from a specified file and loads into @data.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sort-instance_method" title="#sort (instance method)">- (Hash) <strong>sort</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Sorts @data using a quicksort algorithm based on the hash element's
timestamp.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#split_write-instance_method" title="#split_write (instance method)">- (Statsrb) <strong>split_write</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Locates data from a specified file and loads into @data.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#write-instance_method" title="#write (instance method)">- (Statsrb) <strong>write</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Writes the @data in memory to a specified file.</p>
</div></span>
  
</li>

      
    </ul>
  

<div id="constructor_details" class="method_details_list">
  <h2>Constructor Details</h2>
  
    <div class="method_details first">
  <h3 class="signature first" id="initialize-instance_method">
  
    - (<tt>Object</tt>) <strong>initialize</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Class constructor, sets up an instance variable.</p>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/statsrb/statsrb.c', line 512</span>

static VALUE statsrb_constructor(VALUE self) {
  VALUE statsrb_data = rb_ary_new();
  rb_iv_set(self, &quot;@data&quot;, statsrb_data);
  VALUE statsrb_split_file_dir = rb_str_new(&quot;/tmp&quot;, 4);
  rb_iv_set(self, &quot;@split_file_dir&quot;, statsrb_split_file_dir);
  rb_iv_set(self, &quot;@flush_count&quot;, INT2NUM(9));

  // Internal symbols for :ts, :ns and :v.
  VALUE statsrb_key_ts = rb_str_intern(rb_str_new2(&quot;ts&quot;));
  rb_iv_set(self, &quot;@key_ts&quot;, statsrb_key_ts);
  VALUE statsrb_key_ns = rb_str_intern(rb_str_new2(&quot;ns&quot;));
  rb_iv_set(self, &quot;@key_ns&quot;, statsrb_key_ns);
  VALUE statsrb_key_v = rb_str_intern(rb_str_new2(&quot;v&quot;));
  rb_iv_set(self, &quot;@key_v&quot;, statsrb_key_v);

  return self;
}</pre>
    </td>
  </tr>
</table>
</div>
  
</div>

  <div id="instance_attr_details" class="attr_details">
    <h2>Instance Attribute Details</h2>
    
      
      <span id="data=-instance_method"></span>
      <div class="method_details first">
  <h3 class="signature first" id="data-instance_method">
  
    - (<tt>Object</tt>) <strong>data</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>An array of hashes keyed with :ts(timestamp), :ns(namespace) and :v(value)
e.g. [{:ts =&gt; Time.now.to_i, :ns =&gt; "test", :v =&gt; 33}]</p>


  </div>
</div>
<div class="tags">
  

</div>
</div>
    
      
      <span id="flush_count=-instance_method"></span>
      <div class="method_details ">
  <h3 class="signature " id="flush_count-instance_method">
  
    - (<tt>Object</tt>) <strong>flush_count</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>When used with a rack server, the max count of @data before flushing and
writing to file.</p>


  </div>
</div>
<div class="tags">
  

</div>
</div>
    
      
      <span id="split_file_dir=-instance_method"></span>
      <div class="method_details ">
  <h3 class="signature " id="split_file_dir-instance_method">
  
    - (<tt>Object</tt>) <strong>split_file_dir</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>The file directory to write when splitting namespaces. @see #split_write</p>


  </div>
</div>
<div class="tags">
  

</div>
</div>
    
  </div>


  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>

    
      <div class="method_details first">
  <h3 class="signature first" id="call-instance_method">
  
    - (<tt>Object</tt>) <strong>call</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Returns a rack-compatible response.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>env</span>
      
      
        <span class='type'>(<tt>Hash</tt>)</span>
      
      
      
    </li>
  
</ul>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/statsrb/statsrb.c', line 321</span>

static VALUE statsrb_rack_call(VALUE self, VALUE env) {
  VALUE response = rb_ary_new();
  VALUE headers = rb_hash_new();
  VALUE body = rb_ary_new();
  VALUE statsrb_data = rb_iv_get(self, &quot;@data&quot;);
  VALUE statsrb_hash = rb_hash_new();

  // @data hash key symbols.
  VALUE statsrb_key_ts = rb_iv_get(self, &quot;@key_ts&quot;);
  VALUE statsrb_key_ns = rb_iv_get(self, &quot;@key_ns&quot;);
  VALUE statsrb_key_v = rb_iv_get(self, &quot;@key_v&quot;);

  char *path = RSTRING_PTR(rb_hash_aref(env, rb_str_new2(&quot;PATH_INFO&quot;)));

  rb_hash_aset(headers, rb_str_new2(&quot;Content-Type&quot;), rb_str_new2(&quot;text/json&quot;));

  // Parse the query string
  char *qs = RSTRING_PTR(rb_hash_aref(env, rb_str_new2(&quot;QUERY_STRING&quot;)));
  VALUE query_string = statsrb_parse_qs(qs);

  //const char *method = RSTRING_PTR(rb_hash_aref(env, rb_str_new2(&quot;REQUEST_METHOD&quot;)));
  // @TODO consider moving the request method to the proper REQUEST_METHOD
  const char *method_get = &quot;get&quot;;
  const char *method_getu = &quot;GET&quot;;
  const char *method_put = &quot;put&quot;;
  const char *method_putu = &quot;PUT&quot;;
  // Remove the leading /
  path++;
  const char *method = strtok(path, &quot;/\0&quot;);
  if (method &amp;&amp; (strcmp(method, method_put) == 0 || strcmp(method, method_putu) == 0)) {
    long int statsrb_ts, statsrb_v;

    // Get the timestamp, default to now.
    VALUE statsrb_ts_qs = rb_hash_aref(query_string, rb_str_new(&quot;time&quot;, 4));
    if (statsrb_ts_qs != Qnil) {
      statsrb_ts = atoi(RSTRING_PTR(statsrb_ts_qs ));
    }
    else {
      statsrb_ts = (long int)time(NULL);
    }

    // Get the namespace.
    VALUE statsrb_ns = rb_hash_aref(query_string, rb_str_new(&quot;name&quot;, 4));
    if (statsrb_ns == Qnil) {
      statsrb_ns = NULL;
    }

    if (statsrb_ns) {
      // Get the value.
      statsrb_v= 0;
      VALUE statsrb_v_qs = rb_hash_aref(query_string, rb_str_new(&quot;value&quot;, 5));
      if (statsrb_v_qs != Qnil) {
        statsrb_v = atoi(RSTRING_PTR(statsrb_v_qs));
      }

      rb_hash_aset(statsrb_hash, statsrb_key_ts, INT2NUM(statsrb_ts));
      rb_hash_aset(statsrb_hash, statsrb_key_ns, statsrb_ns);
      rb_hash_aset(statsrb_hash, statsrb_key_v, INT2NUM(statsrb_v));
      rb_ary_push(statsrb_data, statsrb_hash);

      int data_length = RARRAY_LEN(statsrb_data);
      rb_ary_push(body, rb_obj_as_string(INT2NUM(RARRAY_LEN(statsrb_data))));

      if (data_length &gt; NUM2INT(rb_iv_get(self, &quot;@flush_count&quot;))) {
        statsrb_sort(self);
        statsrb_split_write(self, rb_iv_get(self, &quot;@split_file_dir&quot;), rb_str_new2(&quot;a+&quot;));
        rb_ary_resize(statsrb_data, 0);
      }

      rb_ary_push(body, statsrb_ns);
    }
  }
  else if (method &amp;&amp; (strcmp(method, method_get) == 0 || strcmp(method, method_getu) == 0)) {
    const char * statsrb_str_ns = strtok(NULL, &quot;/\0&quot;);
    if (statsrb_str_ns == NULL) {
      statsrb_str_ns = &quot;data&quot;;
    }

    VALUE jsoncallback = rb_hash_aref(query_string, rb_str_new(&quot;jsoncallback&quot;, 12));
    if (jsoncallback != Qnil) {
      rb_ary_push(body, rb_str_plus(jsoncallback, rb_str_new(&quot;(&quot;, 1)));
    }
    char json_start[256];
    sprintf(json_start, &quot;{\&quot;%s\&quot;:[&quot;, statsrb_str_ns);
    rb_ary_push(body, rb_str_new2(json_start));

    // If they didn't specify a namespace, bail out immediately.
    if (statsrb_str_ns) {
      VALUE statsrb_ns = rb_str_new2(statsrb_str_ns);
      long int query_limit, query_start, query_end;

      // Get the query limit.
      query_limit = 100;
      VALUE query_limit_qs = rb_hash_aref(query_string, rb_str_new(&quot;limit&quot;, 5));
      if (query_limit_qs != Qnil) {
        query_limit = atoi(RSTRING_PTR(query_limit_qs));
      }

      // Get the query start.
      query_start = 0;
      VALUE query_start_qs = rb_hash_aref(query_string, rb_str_new(&quot;start&quot;, 5));
      if (query_start_qs != Qnil) {
        query_start = atoi(RSTRING_PTR(query_start_qs));
      }

      // Get the query end.
      query_end = 0;
      VALUE query_end_qs = rb_hash_aref(query_string, rb_str_new(&quot;end&quot;, 3));
      if (query_end_qs != Qnil) {
        query_end = atoi(RSTRING_PTR(query_end_qs));
      }

      // Get the past N seconds of data.
      // @TODO the query method fails if we query for data newer than the last entry.
      VALUE query_recent = rb_hash_aref(query_string, rb_str_new(&quot;recent&quot;, 6));
      if (query_recent != Qnil) {
        query_end = (long int)time(NULL);
        long int history = atoi(RSTRING_PTR(query_recent));
        query_start = query_end - history;
      }

      // Create a new Statsrb object to query from.
      // @todo we probably need to assign a new array to @data to avoid messing up the pointers.
      VALUE tmp = rb_obj_dup(self);
      VALUE tmp_data = rb_ary_new();
      rb_iv_set(tmp, &quot;@data&quot;, tmp_data);
      statsrb_read(tmp, rb_str_plus(rb_iv_get(self, &quot;@split_file_dir&quot;), statsrb_ns), statsrb_ns, INT2NUM(query_limit), INT2NUM(query_start), INT2NUM(query_end));
      statsrb_sort(tmp);

      int i, data_length = RARRAY_LEN(tmp_data);

      for (i = 0; i &lt; data_length; i++) {
        rb_ary_push(body, rb_str_new(&quot;[&quot;, 1));
        rb_ary_push(body, rb_obj_as_string(rb_hash_aref(rb_ary_entry(tmp_data, i), statsrb_key_ts )));
        rb_ary_push(body, rb_str_new(&quot;,&quot;, 1));
        rb_ary_push(body, rb_obj_as_string(rb_hash_aref(rb_ary_entry(tmp_data, i), statsrb_key_v )));
        rb_ary_push(body, rb_str_new(&quot;]&quot;, 1));
        if (i &lt; data_length - 1) {
          rb_ary_push(body, rb_str_new(&quot;,&quot;, 1));
        }
        rb_ary_push(body, rb_str_new(&quot;\n&quot;, 1));
      }
      rb_ary_resize(tmp_data, 0);
    }
    rb_ary_push(body, rb_str_new(&quot;]}&quot;, 2));
    if (jsoncallback != Qnil) {
      rb_ary_push(body, rb_str_new(&quot;)&quot;, 1));
    }
  }
  else {
    rb_ary_push(response, INT2NUM(404));
    rb_ary_push(response, headers);
    rb_ary_push(response, body);
    return response;
  }

  rb_ary_push(response, INT2NUM(200));
  rb_ary_push(response, headers);
  rb_ary_push(response, body);

  return response;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="get-instance_method">
  
    - (<tt>Array</tt>) <strong>get</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Retrieves internal data based on specified filters.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>namespace</span>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>limit</span>
      
      
        <span class='type'>(<tt>Number</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>start_time</span>
      
      
        <span class='type'>(<tt>Number</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>end_time</span>
      
      
        <span class='type'>(<tt>Number</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Array</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>An array of data hashes.</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/statsrb/statsrb.c', line 14</span>

static VALUE statsrb_get(VALUE self, VALUE query_ns, VALUE query_limit, VALUE query_start, VALUE query_end) {
  VALUE statsrb_data = rb_iv_get(self, &quot;@data&quot;);
  VALUE statsrb_event = rb_hash_new();
  int data_length = RARRAY_LEN(statsrb_data);
  int i = 0;
  int count = 0;
  int tmp_ts;

  VALUE filtered_data = rb_ary_new();
  VALUE tmp_ns;

  // @data hash key symbols.
  VALUE statsrb_key_ts = rb_iv_get(self, &quot;@key_ts&quot;);
  VALUE statsrb_key_ns = rb_iv_get(self, &quot;@key_ns&quot;);
  VALUE statsrb_key_v = rb_iv_get(self, &quot;@key_v&quot;);

  // Convert into an int that ruby understands.
  int limit = NUM2INT(query_limit);
  int qstart = NUM2INT(query_start);
  int qend = NUM2INT(query_end);

  for (i = 0; i &lt; data_length; i++) {
    tmp_ts = NUM2INT(rb_hash_aref(rb_ary_entry(statsrb_data, i), statsrb_key_ts));
    tmp_ns = rb_hash_aref(rb_ary_entry(statsrb_data, i), statsrb_key_ns);
    if (rb_str_equal(query_ns, tmp_ns)
        &amp;&amp; (qstart == 0 || tmp_ts &gt;= qstart)
        &amp;&amp; (qend == 0 || tmp_ts &lt;= qend)) {
      rb_hash_aset(statsrb_event, statsrb_key_ts, rb_hash_aref(rb_ary_entry(statsrb_data, i), statsrb_key_ts));
      rb_hash_aset(statsrb_event, statsrb_key_ns, rb_hash_aref(rb_ary_entry(statsrb_data, i), statsrb_key_ns));
      rb_hash_aset(statsrb_event, statsrb_key_v, rb_hash_aref(rb_ary_entry(statsrb_data, i), statsrb_key_v));
      rb_ary_push(filtered_data, statsrb_event);
      count++;
    }
  }

  return filtered_data;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="push-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="Statsrb (class)">Statsrb</a></span></tt>) <strong>push</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Pushes a stat onto the statsrb object.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>timestamp</span>
      
      
        <span class='type'>(<tt>Number</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>namespace</span>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>value</span>
      
      
        <span class='type'>(<tt>Number</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Statsrb (class)">Statsrb</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>A reference to the object.</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/statsrb/statsrb.c', line 491</span>

static VALUE statsrb_push(VALUE self, VALUE timestamp, VALUE namespace, VALUE value) {
  VALUE statsrb_data = rb_iv_get(self, &quot;@data&quot;);
  VALUE statsrb_event = rb_hash_new();

  // @data hash key symbols.
  VALUE statsrb_key_ts = rb_iv_get(self, &quot;@key_ts&quot;);
  VALUE statsrb_key_ns = rb_iv_get(self, &quot;@key_ns&quot;);
  VALUE statsrb_key_v = rb_iv_get(self, &quot;@key_v&quot;);

  rb_hash_aset(statsrb_event, statsrb_key_ts, timestamp);
  rb_hash_aset(statsrb_event, statsrb_key_ns, namespace);
  rb_hash_aset(statsrb_event, statsrb_key_v, value);

  rb_ary_push(statsrb_data, statsrb_event);

  return self;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="query-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="Statsrb (class)">Statsrb</a></span></tt>) <strong>query</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Locates data from a specified file and loads into @data.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>filepath</span>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>namespace</span>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>limit</span>
      
      
        <span class='type'>(<tt>Number</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>start_time</span>
      
      
        <span class='type'>(<tt>Number</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>end_time</span>
      
      
        <span class='type'>(<tt>Number</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Statsrb (class)">Statsrb</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>A reference to the object.</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/statsrb/statsrb.c', line 61</span>

static VALUE statsrb_read(VALUE self, VALUE logfile, VALUE query_ns, VALUE query_limit, VALUE query_start, VALUE query_end) {
  FILE * file;
  int line_size = 256;
  char *line = (char *) malloc(line_size);
  const char *filepath = RSTRING_PTR(logfile);
  const char *query_ns_char = RSTRING_PTR(query_ns);

  // @data hash key symbols.
  VALUE statsrb_key_ts = rb_iv_get(self, &quot;@key_ts&quot;);
  VALUE statsrb_key_ns = rb_iv_get(self, &quot;@key_ns&quot;);
  VALUE statsrb_key_v = rb_iv_get(self, &quot;@key_v&quot;);
  // Create an empty string for comparison.
  VALUE statsrb_str_empty = rb_str_new2(&quot;&quot;);

  // Convert into an int that ruby understands.
  int limit = NUM2INT(query_limit);
  int qstart = NUM2INT(query_start);
  int qend = NUM2INT(query_end);

  // Return array instantiation.
  VALUE statsrb_data = rb_iv_get(self, &quot;@data&quot;);
  // @TODO does this garbage collect all of the old hash data?
  rb_ary_resize(statsrb_data, 0);

  file = fopen(filepath, &quot;r&quot;);
  if (file == NULL) {
    fprintf(stderr, &quot;File error: could not open file %s for reading.&quot;, filepath);
    return self;
  }

  int count = 0;

  while (NULL != fgets(line, line_size, file) &amp;&amp; count &lt; limit) {
    // strstr doesn't work with newline chars.
    size_t len = strlen(line) - 1;
    if (line[len] == '\n');
        line[len] = '\0';

    // If the namespace is in the row, explode it.
    if (line[0] != '\0' &amp;&amp; line[0] != '\n' &amp;&amp; strchr(line, query_ns_char[0]) &amp;&amp; strstr(line, query_ns_char)) {
      VALUE statsrb_event = rb_hash_new();

      // I tried sscanf for convenience, but it was predictably slower.
      //int statsrb_ts, statsrb_v;
      //sscanf(line, &quot;%d\t%*s\t%d&quot;, &amp;statsrb_ts, &amp;statsrb_v);

      // @TODO this should something more robust than atoi.
      int statsrb_ts = atoi(strtok(line, &quot;\t&quot;));

      if (statsrb_ts != NULL &amp;&amp; (qstart == 0 || statsrb_ts &gt;= qstart) &amp;&amp; (qend == 0 || statsrb_ts &lt;= qend)) {
        // @TODO this should probably use the actual namespace if we do wildcard queries.
        VALUE statsrb_str_ns = rb_str_new2(strtok(NULL, &quot;\t&quot;));
        //strtok(NULL, &quot;\t&quot;);
        int statsrb_v = atoi(strtok(NULL, &quot;\0&quot;));

        // @TODO this should really query the namespace exactly instead of just relying on strstr.
        //if (rb_str_cmp(query_ns, statsrb_str_empty) == 0 || rb_str_cmp(query_ns, statsrb_str_ns) == 0) {
        if (statsrb_ts &amp;&amp; (statsrb_v || statsrb_v == 0)) {
          rb_hash_aset(statsrb_event, statsrb_key_ts, INT2NUM(statsrb_ts));
          rb_hash_aset(statsrb_event, statsrb_key_ns, statsrb_str_ns);
          //rb_hash_aset(statsrb_event, statsrb_key_ns, query_ns);
          rb_hash_aset(statsrb_event, statsrb_key_v, INT2NUM(statsrb_v));
          rb_ary_push(statsrb_data, statsrb_event);
          count++;
        }
      }
    }
  }

  // terminate
  fclose (file);
  free (line);

  //return statsrb_data;
  //rb_iv_set(self, &quot;@data&quot;, statsrb_data);

  return self;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="read-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="Statsrb (class)">Statsrb</a></span></tt>) <strong>read</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Locates data from a specified file and loads into @data.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>filepath</span>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>namespace</span>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>limit</span>
      
      
        <span class='type'>(<tt>Number</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>start_time</span>
      
      
        <span class='type'>(<tt>Number</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>end_time</span>
      
      
        <span class='type'>(<tt>Number</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Statsrb (class)">Statsrb</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>A reference to the object.</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/statsrb/statsrb.c', line 61</span>

static VALUE statsrb_read(VALUE self, VALUE logfile, VALUE query_ns, VALUE query_limit, VALUE query_start, VALUE query_end) {
  FILE * file;
  int line_size = 256;
  char *line = (char *) malloc(line_size);
  const char *filepath = RSTRING_PTR(logfile);
  const char *query_ns_char = RSTRING_PTR(query_ns);

  // @data hash key symbols.
  VALUE statsrb_key_ts = rb_iv_get(self, &quot;@key_ts&quot;);
  VALUE statsrb_key_ns = rb_iv_get(self, &quot;@key_ns&quot;);
  VALUE statsrb_key_v = rb_iv_get(self, &quot;@key_v&quot;);
  // Create an empty string for comparison.
  VALUE statsrb_str_empty = rb_str_new2(&quot;&quot;);

  // Convert into an int that ruby understands.
  int limit = NUM2INT(query_limit);
  int qstart = NUM2INT(query_start);
  int qend = NUM2INT(query_end);

  // Return array instantiation.
  VALUE statsrb_data = rb_iv_get(self, &quot;@data&quot;);
  // @TODO does this garbage collect all of the old hash data?
  rb_ary_resize(statsrb_data, 0);

  file = fopen(filepath, &quot;r&quot;);
  if (file == NULL) {
    fprintf(stderr, &quot;File error: could not open file %s for reading.&quot;, filepath);
    return self;
  }

  int count = 0;

  while (NULL != fgets(line, line_size, file) &amp;&amp; count &lt; limit) {
    // strstr doesn't work with newline chars.
    size_t len = strlen(line) - 1;
    if (line[len] == '\n');
        line[len] = '\0';

    // If the namespace is in the row, explode it.
    if (line[0] != '\0' &amp;&amp; line[0] != '\n' &amp;&amp; strchr(line, query_ns_char[0]) &amp;&amp; strstr(line, query_ns_char)) {
      VALUE statsrb_event = rb_hash_new();

      // I tried sscanf for convenience, but it was predictably slower.
      //int statsrb_ts, statsrb_v;
      //sscanf(line, &quot;%d\t%*s\t%d&quot;, &amp;statsrb_ts, &amp;statsrb_v);

      // @TODO this should something more robust than atoi.
      int statsrb_ts = atoi(strtok(line, &quot;\t&quot;));

      if (statsrb_ts != NULL &amp;&amp; (qstart == 0 || statsrb_ts &gt;= qstart) &amp;&amp; (qend == 0 || statsrb_ts &lt;= qend)) {
        // @TODO this should probably use the actual namespace if we do wildcard queries.
        VALUE statsrb_str_ns = rb_str_new2(strtok(NULL, &quot;\t&quot;));
        //strtok(NULL, &quot;\t&quot;);
        int statsrb_v = atoi(strtok(NULL, &quot;\0&quot;));

        // @TODO this should really query the namespace exactly instead of just relying on strstr.
        //if (rb_str_cmp(query_ns, statsrb_str_empty) == 0 || rb_str_cmp(query_ns, statsrb_str_ns) == 0) {
        if (statsrb_ts &amp;&amp; (statsrb_v || statsrb_v == 0)) {
          rb_hash_aset(statsrb_event, statsrb_key_ts, INT2NUM(statsrb_ts));
          rb_hash_aset(statsrb_event, statsrb_key_ns, statsrb_str_ns);
          //rb_hash_aset(statsrb_event, statsrb_key_ns, query_ns);
          rb_hash_aset(statsrb_event, statsrb_key_v, INT2NUM(statsrb_v));
          rb_ary_push(statsrb_data, statsrb_event);
          count++;
        }
      }
    }
  }

  // terminate
  fclose (file);
  free (line);

  //return statsrb_data;
  //rb_iv_set(self, &quot;@data&quot;, statsrb_data);

  return self;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="sort-instance_method">
  
    - (<tt>Hash</tt>) <strong>sort</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Sorts @data using a quicksort algorithm based on the hash element's
timestamp.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Hash</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>The sorted data</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


178
179
180
181
182
183
184
185
186</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/statsrb/statsrb.c', line 178</span>

static VALUE statsrb_sort(VALUE self) {
  VALUE statsrb_data = rb_iv_get(self, &quot;@data&quot;);
  int len = RARRAY_LEN(statsrb_data);
  if (len &gt; 0) {
    VALUE statsrb_key_ts = rb_iv_get(self, &quot;@key_ts&quot;);
    time_sort(0, len - 1, statsrb_data, statsrb_key_ts);
  }
  return statsrb_data;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="split_write-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="Statsrb (class)">Statsrb</a></span></tt>) <strong>split_write</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Locates data from a specified file and loads into @data.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>filepath</span>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>namespace</span>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>limit</span>
      
      
        <span class='type'>(<tt>Number</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>start_time</span>
      
      
        <span class='type'>(<tt>Number</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>end_time</span>
      
      
        <span class='type'>(<tt>Number</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Statsrb (class)">Statsrb</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>A reference to the object.</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/statsrb/statsrb.c', line 240</span>

static VALUE statsrb_split_write(VALUE self, VALUE logdir, VALUE mode) {
  VALUE statsrb_data = rb_iv_get(self, &quot;@data&quot;);
  int len = RARRAY_LEN(statsrb_data);
  int i, ii, ns_len;

  // @data hash key symbols.
  VALUE statsrb_key_ts = rb_iv_get(self, &quot;@key_ts&quot;);
  VALUE statsrb_key_ns = rb_iv_get(self, &quot;@key_ns&quot;);
  VALUE statsrb_key_v = rb_iv_get(self, &quot;@key_v&quot;);

  VALUE ns_list = rb_ary_new();

  for (i = 0; i &lt; len; i++) {
    if (!rb_ary_includes(ns_list, rb_hash_aref(rb_ary_entry(statsrb_data, i), statsrb_key_ns))) {
      rb_ary_push(ns_list, rb_hash_aref(rb_ary_entry(statsrb_data, i), statsrb_key_ns));
    }
  }

  ns_len = RARRAY_LEN(ns_list);

  for (i = 0; i &lt; ns_len; i++) {
    VALUE tmp = rb_obj_dup(self);
    VALUE tmp_data = rb_ary_new();
    for (ii = 0; ii &lt; len; ii++) {
      if (rb_str_cmp(rb_ary_entry(ns_list, i), rb_hash_aref(rb_ary_entry(statsrb_data, ii), statsrb_key_ns)) == 0) {
        rb_ary_push(tmp_data, rb_ary_entry(statsrb_data, ii));
      }
    }
    //fputs (RSTRING_PTR(rb_obj_as_string(INT2NUM(RARRAY_LEN(tmp_data)))),stderr);
    rb_iv_set(tmp, &quot;@data&quot;, tmp_data);

    // If there is no trailing slash on the log dir, add one.
    const char *filepath = RSTRING_PTR(logdir);
    size_t len = strlen(filepath);
    if (filepath[len - 1] != '/') {
      logdir = rb_str_plus(logdir, rb_str_new2(&quot;/&quot;));
    }
    statsrb_write(tmp, rb_str_plus(logdir, rb_ary_entry(ns_list, i)), mode);
  }

  return self;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="write-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="Statsrb (class)">Statsrb</a></span></tt>) <strong>write</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Writes the @data in memory to a specified file.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>filepath</span>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>filemode</span>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Statsrb (class)">Statsrb</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>A reference to the object.</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/statsrb/statsrb.c', line 194</span>

static VALUE statsrb_write(VALUE self, VALUE logfile, VALUE mode) {
  FILE * file;
  const char *filepath = RSTRING_PTR(logfile);
  const char *filemode = RSTRING_PTR(mode);
  VALUE statsrb_data = rb_iv_get(self, &quot;@data&quot;);
  int data_length = RARRAY_LEN(statsrb_data);
  int i;
  int line_size = 256;
  int tmp_ts, tmp_v;
  const char *tmp_ns = (char *) malloc(line_size);

  // @data hash key symbols.
  VALUE statsrb_key_ts = rb_iv_get(self, &quot;@key_ts&quot;);
  VALUE statsrb_key_ns = rb_iv_get(self, &quot;@key_ns&quot;);
  VALUE statsrb_key_v = rb_iv_get(self, &quot;@key_v&quot;);

  file = fopen(filepath, filemode);
  if (file==NULL) {
    fprintf(stderr, &quot;File error: could not open file %s mode %s.&quot;, filepath, filemode);
    return self;
  }

  // Iterate through the data array, writing the data as we go.
  for (i = 0; i &lt; data_length; i++) {
    // @TODO make sure that these values are not empty before writing.
    //VALUE tmp_line = rb_str_tmp_new(line_size);
    tmp_ts = NUM2INT(rb_hash_aref(rb_ary_entry(statsrb_data, i), statsrb_key_ts));
    tmp_ns = RSTRING_PTR(rb_hash_aref(rb_ary_entry(statsrb_data, i), statsrb_key_ns));
    tmp_v = NUM2INT(rb_hash_aref(rb_ary_entry(statsrb_data, i), statsrb_key_v));
    fprintf(file, &quot;%d\t%s\t%d\n&quot;, tmp_ts, tmp_ns, tmp_v);
    //rb_str_free(tmp_line);
  }

  fclose (file);
  return self;
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>

    <div id="footer">
  Generated on Tue Jun 11 10:44:06 2013 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.8.6.1 (ruby-1.9.3).
</div>

  </body>
</html>